include:
  - template: Jobs/Container-Scanning.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
  - template: Jobs/SAST.gitlab-ci.yml
  - template: Jobs/SAST-IaC.gitlab-ci.yml
  - template: Jobs/Secret-Detection.gitlab-ci.yml
  - template: Code-Quality.gitlab-ci.yml
  # Commented out as we are using our own tool for license scanning
  # - template: Jobs/License-Scanning.gitlab-ci.yml

stages:
  - test
  - publish
  - container_scanning

# Only start pipelines on Merge Requests or the default branch
workflow:
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      when: always
    - if: $CI_MERGE_REQUEST_IID
      when: always
    - if: $CI_COMMIT_TAG
      when: always
    - when: never

variables:
  GO_VERSION: "1.18.2"
  CGO_ENABLED: "0"
  GOPATH_RELATIVE_PATH: .go
  GOPATH: "$CI_PROJECT_DIR/$GOPATH_RELATIVE_PATH"
  GOCACHE: "$GOPATH/cache"
  SAST_EXCLUDED_PATHS: "$GOPATH_RELATIVE_PATH, docker-compose"
  SECRET_DETECTION_EXCLUDED_PATHS: "$GOPATH_RELATIVE_PATH"

default:
  tags:
    - oss
  retry:
    max: 2
    when:
      - unknown_failure
      - api_failure
      - stuck_or_timeout_failure
      - runner_system_failure
  interruptible: true

.cache-template: &cache-template
  key: "$CI_JOB_NAME-$CI_COMMIT_REF_SLUG"
  paths:
    - ".go/pkg/mod"
    - ".go/cache"

#################################
##            RULES            ##
#################################

.on_merge_request_and_merged_events:
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_PIPELINE_SOURCE == "merge_request_event"'

.on_tag_events:
  rules:
    - if: '$CI_COMMIT_TAG'

.on_default_branch_and_merge_train_with_golang_changes:
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $CI_MERGE_REQUEST_EVENT_TYPE == "merge_train"
      changes:
        - "**/go.mod"
        - "**/go.sum"
        - go.mod
        - go.sum

#################################
##            BUILD            ##
#################################

publish api docker:
  image: docker:latest
  services:
    - docker:dind
  stage: publish
  tags:
    - oss
    - docker
  variables:
    KUBERNETES_SERVICE_MEMORY_LIMIT: 1Gi
    KUBERNETES_SERVICE_CPU_LIMIT: "1"
  before_script:
    - apk add git
  rules:
    - !reference [.on_tag_events, rules]
  script:
    - |
      echo "This is a tagged commit so major, major.minor and full tags will be pushed to GitLab registry"

      # Version is based on semantic versioning
      full_version=$(docker run --rm -v "$(pwd)":/git-semver mdomke/git-semver | grep -Eo '[0-9\.].*$')
      major_version=$(docker run --rm -v "$(pwd)":/git-semver mdomke/git-semver -format x | grep -Eo '[0-9\.].*$')
      major_minor_version=$(docker run --rm -v "$(pwd)":/git-semver mdomke/git-semver -format x.y | grep -Eo '[0-9\.].*$')

      # Build registry URIs.
      registry_uri="$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME"
      api_uri="$registry_uri"/api

      docker login -u gitlab-ci-token -p "$CI_JOB_TOKEN" "$CI_REGISTRY"

      echo "Building tharsis-api image"
      docker build --target api -t api:latest --build-arg goversion=$GO_VERSION --no-cache .

      # Version tag API images.
      echo "Version tagging the api image"
      docker image tag api:latest $api_uri:$full_version
      docker image tag api:latest $api_uri:$major_version
      docker image tag api:latest $api_uri:$major_minor_version

      echo "Pushing tharsis-api versioned image to registry"
      docker image push $api_uri:$full_version
      docker image push $api_uri:$major_version
      docker image push $api_uri:$major_minor_version

      latest_version=$(git tag | tr - \~ | sort -rV | tr \~ - | head -n1)
      if [[ "$CI_COMMIT_TAG" == "$latest_version" ]]
        then
          echo "Build is latest, tagging and pushing image as latest"
          docker image tag api:latest $api_uri:latest
          docker image push $api_uri:latest
      fi
  interruptible: false

publish job-executor docker:
  image: docker:latest
  services:
    - docker:dind
  stage: publish
  tags:
    - oss
    - docker
  variables:
    KUBERNETES_SERVICE_MEMORY_LIMIT: 1Gi
    KUBERNETES_SERVICE_CPU_LIMIT: "1"
  before_script:
    - apk add git
  rules:
    - !reference [.on_tag_events, rules]
  script:
    - |
      echo "This is a tagged commit so major, major.minor and full tags will be pushed to GitLab registry"

      # Version is based on semantic versioning
      full_version=$(docker run --rm -v "$(pwd)":/git-semver mdomke/git-semver | grep -Eo '[0-9\.].*$')
      major_version=$(docker run --rm -v "$(pwd)":/git-semver mdomke/git-semver -format x | grep -Eo '[0-9\.].*$')
      major_minor_version=$(docker run --rm -v "$(pwd)":/git-semver mdomke/git-semver -format x.y | grep -Eo '[0-9\.].*$')

      # Build registry URIs.
      registry_uri="$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME"
      job_executor_uri="$registry_uri"/job-executor

      docker login -u gitlab-ci-token -p "$CI_JOB_TOKEN" "$CI_REGISTRY"

      echo "Building job-executor image"
      docker build --target job-executor -t job-executor:latest --build-arg goversion=$GO_VERSION --no-cache .

      # Version tag job executor images.
      echo "Version tagging the job-executor image"
      docker image tag job-executor:latest $job_executor_uri:$full_version
      docker image tag job-executor:latest $job_executor_uri:$major_version
      docker image tag job-executor:latest $job_executor_uri:$major_minor_version

      echo "Pushing job-executor versioned image to registry"
      docker image push $job_executor_uri:$full_version
      docker image push $job_executor_uri:$major_version
      docker image push $job_executor_uri:$major_minor_version

      latest_version=$(git tag | tr - \~ | sort -rV | tr \~ - | head -n1)
      if [[ "$CI_COMMIT_TAG" == "$latest_version" ]]
        then
          echo "Build is latest, tagging and pushing image as latest"
          docker image tag job-executor:latest $job_executor_uri:latest
          docker image push $job_executor_uri:latest
      fi
  interruptible: false

tests:
  image: golang:${GO_VERSION}-alpine
  needs: []
  services:
    - postgres:13.4
  stage: test
  variables:
    POSTGRES_DB: tharsisdbtest
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: $CI_JOB_TOKEN
    THARSIS_DB_TEST_HOST: postgres
    THARSIS_DB_TEST_PORT: 5432
    THARSIS_DB_TEST_SSL_MODE: disable
    POSTGRES_HOST_AUTH_METHOD: trust
    LD_FLAG_VAR_PREFIX: gitlab.com/infor-cloud/martian-cloud/tharsis/tharsis-api/internal/db
    KUBERNETES_MEMORY_REQUEST: 2Gi
    KUBERNETES_MEMORY_LIMIT: 4Gi
  before_script:
    - export PATH=$PATH:$GOPATH/bin
    - apk add postgresql-client libpq-dev git bash openssh ca-certificates
    - go install github.com/jstemmer/go-junit-report@latest
    - go install github.com/boumenot/gocover-cobertura@latest
    - wget -O - https://github.com/golang-migrate/migrate/releases/download/v4.15.2/migrate.linux-amd64.tar.gz | tar -xzf - -C /usr/local/bin
  script:
    - |
        set -x
        /usr/local/bin/migrate -path=internal/db/migrations/ -database postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${THARSIS_DB_TEST_HOST}:${THARSIS_DB_TEST_PORT}/${POSTGRES_DB}?sslmode=${THARSIS_DB_TEST_SSL_MODE} -verbose up
        go test \
          -tags=integration \
          --ldflags "-X ${LD_FLAG_VAR_PREFIX}.TestDBHost=${THARSIS_DB_TEST_HOST} -X ${LD_FLAG_VAR_PREFIX}.TestDBPort=${THARSIS_DB_TEST_PORT} -X ${LD_FLAG_VAR_PREFIX}.TestDBName=${POSTGRES_DB} -X ${LD_FLAG_VAR_PREFIX}.TestDBMode=${THARSIS_DB_TEST_SSL_MODE} -X ${LD_FLAG_VAR_PREFIX}.TestDBUser=${POSTGRES_USER} -X ${LD_FLAG_VAR_PREFIX}.TestDBPass=${POSTGRES_PASSWORD}" \
          -covermode=atomic \
          -coverpkg gitlab.com/infor-cloud/martian-cloud/tharsis/tharsis-api/... \
          -v \
          -coverprofile .coverage \
          ./... 2>&1 | tee .test-results

        go tool cover -func .coverage | tail
        go-junit-report -set-exit-code < .test-results > .xunit-results.xml
        gocover-cobertura < .coverage > coverage.xml
  artifacts:
    when: always
    reports:
      junit: .xunit-results.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
  coverage: '/\(statements\)\s*(\d+(?:\.\d+)?%)/'
  cache:
    <<: *cache-template

lint:
  image: golang:${GO_VERSION}-alpine
  stage: test
  before_script:
    - export PATH=$PATH:$GOPATH/bin
    - apk add git bash openssh ca-certificates
    - go install github.com/mgechev/revive@latest
  script:
    - go mod download
    - |
        # Set similar rules as golint, subject to change
        cat <<EOF > config.toml
        ignoreGeneratedHeader = false
        severity = "warning"
        confidence = 0.8
        errorCode = 0
        warningCode = 0

        [rule.blank-imports]
        [rule.context-as-argument]
        [rule.context-keys-type]
        [rule.dot-imports]
        [rule.error-return]
        [rule.error-strings]
        [rule.error-naming]
        [rule.exported]
        [rule.if-return]
        [rule.increment-decrement]
        [rule.var-naming]
        [rule.var-declaration]
        # [rule.package-comments]
        [rule.range]
        [rule.receiver-naming]
        [rule.time-naming]
        [rule.unexported-return]
        [rule.indent-error-flow]
        [rule.errorf]
        EOF
    - revive -config config.toml -set_exit_status $(go list ./... | grep -v /vendor/)
  cache:
    <<: *cache-template

#################################
##            SAST             ##
#################################

container_scanning:
  stage: container_scanning
  variables:
    CS_IMAGE: "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/api:latest"
    GIT_STRATEGY: fetch
  rules:
    - !reference [.on_tag_events, rules]

gemnasium-dependency_scanning:
  variables:
    DS_EXCLUDED_PATHS: "$GOPATH_RELATIVE_PATH"
  rules:
    - !reference [.on_merge_request_and_merged_events, rules]

semgrep-sast:
  before_script:
    - |
      echo "*_test.go" >> /semgrepignore
  rules:
    - !reference [.on_merge_request_and_merged_events, rules]

kics-iac-sast:
  rules:
    - !reference [.on_merge_request_and_merged_events, rules]

secret_detection:
  rules:
    - !reference [.on_merge_request_and_merged_events, rules]

code_quality:
  tags:
    - oss
    - docker
  artifacts:
    paths: [gl-code-quality-report.json]
  rules:
    - !reference [.on_default_branch_and_merge_train_with_golang_changes, rules]

license_scanning:
  stage: test
  image: golang:${GO_VERSION}-alpine
  allow_failure: true
  before_script:
    - export PATH=$PATH:$GOPATH/bin
    - apk add git bash openssh ca-certificates make jq
    - go install github.com/uw-labs/lichen@latest
  script:
    - make build-api
    - lichen -j lichen.json $CI_PROJECT_DIR/apiserver
    - >
        jq '{"version": "2.1","licenses": [ . | .Modules[] | .Licenses[] | {"id": .Name,"name": .Name, "url": ("https://opensource.org/licenses/" + .Name) } ] | unique,"dependencies":[ . | .Modules[] | {"name": .Path, "version": .Version, "package_manager": "go","path": "go.sum","licenses": [ .Licenses[] | .Name]}]}' lichen.json > gl-license-scanning-report.json
  cache:
    <<: *cache-template
  artifacts:
    reports:
      license_scanning: gl-license-scanning-report.json
    paths: [gl-license-scanning-report.json]
  dependencies: []
  rules:
    - !reference [.on_default_branch_and_merge_train_with_golang_changes, rules]
