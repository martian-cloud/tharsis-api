// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v4.25.6
// source: run.proto

package gen

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Runs_GetRunByID_FullMethodName           = "/martiancloud.tharsis.api.run.Runs/GetRunByID"
	Runs_GetRuns_FullMethodName              = "/martiancloud.tharsis.api.run.Runs/GetRuns"
	Runs_CreateRun_FullMethodName            = "/martiancloud.tharsis.api.run.Runs/CreateRun"
	Runs_ApplyRun_FullMethodName             = "/martiancloud.tharsis.api.run.Runs/ApplyRun"
	Runs_CancelRun_FullMethodName            = "/martiancloud.tharsis.api.run.Runs/CancelRun"
	Runs_GetRunVariables_FullMethodName      = "/martiancloud.tharsis.api.run.Runs/GetRunVariables"
	Runs_GetPlanByID_FullMethodName          = "/martiancloud.tharsis.api.run.Runs/GetPlanByID"
	Runs_GetApplyByID_FullMethodName         = "/martiancloud.tharsis.api.run.Runs/GetApplyByID"
	Runs_UpdatePlan_FullMethodName           = "/martiancloud.tharsis.api.run.Runs/UpdatePlan"
	Runs_UpdateApply_FullMethodName          = "/martiancloud.tharsis.api.run.Runs/UpdateApply"
	Runs_GetLatestJobForPlan_FullMethodName  = "/martiancloud.tharsis.api.run.Runs/GetLatestJobForPlan"
	Runs_GetLatestJobForApply_FullMethodName = "/martiancloud.tharsis.api.run.Runs/GetLatestJobForApply"
	Runs_SubscribeToRunEvents_FullMethodName = "/martiancloud.tharsis.api.run.Runs/SubscribeToRunEvents"
)

// RunsClient is the client API for Runs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Runs implements all functionality related to a Tharsis Run.
type RunsClient interface {
	// GetRunByID returns a Run by an ID.
	GetRunByID(ctx context.Context, in *GetRunByIDRequest, opts ...grpc.CallOption) (*Run, error)
	// GetRuns returns a paginated list of Runs.
	GetRuns(ctx context.Context, in *GetRunsRequest, opts ...grpc.CallOption) (*GetRunsResponse, error)
	// CreateRun creates a new Run.
	CreateRun(ctx context.Context, in *CreateRunRequest, opts ...grpc.CallOption) (*Run, error)
	// ApplyRun applies a Run.
	ApplyRun(ctx context.Context, in *ApplyRunRequest, opts ...grpc.CallOption) (*Run, error)
	// CancelRun cancels a Run.
	CancelRun(ctx context.Context, in *CancelRunRequest, opts ...grpc.CallOption) (*Run, error)
	// GetRunVariables returns variables for a Run.
	GetRunVariables(ctx context.Context, in *GetRunVariablesRequest, opts ...grpc.CallOption) (*GetRunVariablesResponse, error)
	// GetPlanByID returns a Plan by an ID.
	GetPlanByID(ctx context.Context, in *GetPlanByIDRequest, opts ...grpc.CallOption) (*Plan, error)
	// GetApplyByID returns an Apply by an ID.
	GetApplyByID(ctx context.Context, in *GetApplyByIDRequest, opts ...grpc.CallOption) (*Apply, error)
	// UpdatePlan updates a Plan.
	UpdatePlan(ctx context.Context, in *UpdatePlanRequest, opts ...grpc.CallOption) (*Plan, error)
	// UpdateApply updates an Apply.
	UpdateApply(ctx context.Context, in *UpdateApplyRequest, opts ...grpc.CallOption) (*Apply, error)
	// GetLatestJobForPlan returns the latest job for a Plan.
	GetLatestJobForPlan(ctx context.Context, in *GetLatestJobForPlanRequest, opts ...grpc.CallOption) (*Job, error)
	// GetLatestJobForApply returns the latest job for an Apply.
	GetLatestJobForApply(ctx context.Context, in *GetLatestJobForApplyRequest, opts ...grpc.CallOption) (*Job, error)
	// SubscribeToRunEvents subscribes to run events.
	SubscribeToRunEvents(ctx context.Context, in *SubscribeToRunEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RunEvent], error)
}

type runsClient struct {
	cc grpc.ClientConnInterface
}

func NewRunsClient(cc grpc.ClientConnInterface) RunsClient {
	return &runsClient{cc}
}

func (c *runsClient) GetRunByID(ctx context.Context, in *GetRunByIDRequest, opts ...grpc.CallOption) (*Run, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Run)
	err := c.cc.Invoke(ctx, Runs_GetRunByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runsClient) GetRuns(ctx context.Context, in *GetRunsRequest, opts ...grpc.CallOption) (*GetRunsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRunsResponse)
	err := c.cc.Invoke(ctx, Runs_GetRuns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runsClient) CreateRun(ctx context.Context, in *CreateRunRequest, opts ...grpc.CallOption) (*Run, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Run)
	err := c.cc.Invoke(ctx, Runs_CreateRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runsClient) ApplyRun(ctx context.Context, in *ApplyRunRequest, opts ...grpc.CallOption) (*Run, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Run)
	err := c.cc.Invoke(ctx, Runs_ApplyRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runsClient) CancelRun(ctx context.Context, in *CancelRunRequest, opts ...grpc.CallOption) (*Run, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Run)
	err := c.cc.Invoke(ctx, Runs_CancelRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runsClient) GetRunVariables(ctx context.Context, in *GetRunVariablesRequest, opts ...grpc.CallOption) (*GetRunVariablesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRunVariablesResponse)
	err := c.cc.Invoke(ctx, Runs_GetRunVariables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runsClient) GetPlanByID(ctx context.Context, in *GetPlanByIDRequest, opts ...grpc.CallOption) (*Plan, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Plan)
	err := c.cc.Invoke(ctx, Runs_GetPlanByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runsClient) GetApplyByID(ctx context.Context, in *GetApplyByIDRequest, opts ...grpc.CallOption) (*Apply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Apply)
	err := c.cc.Invoke(ctx, Runs_GetApplyByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runsClient) UpdatePlan(ctx context.Context, in *UpdatePlanRequest, opts ...grpc.CallOption) (*Plan, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Plan)
	err := c.cc.Invoke(ctx, Runs_UpdatePlan_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runsClient) UpdateApply(ctx context.Context, in *UpdateApplyRequest, opts ...grpc.CallOption) (*Apply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Apply)
	err := c.cc.Invoke(ctx, Runs_UpdateApply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runsClient) GetLatestJobForPlan(ctx context.Context, in *GetLatestJobForPlanRequest, opts ...grpc.CallOption) (*Job, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Job)
	err := c.cc.Invoke(ctx, Runs_GetLatestJobForPlan_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runsClient) GetLatestJobForApply(ctx context.Context, in *GetLatestJobForApplyRequest, opts ...grpc.CallOption) (*Job, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Job)
	err := c.cc.Invoke(ctx, Runs_GetLatestJobForApply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runsClient) SubscribeToRunEvents(ctx context.Context, in *SubscribeToRunEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RunEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Runs_ServiceDesc.Streams[0], Runs_SubscribeToRunEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeToRunEventsRequest, RunEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Runs_SubscribeToRunEventsClient = grpc.ServerStreamingClient[RunEvent]

// RunsServer is the server API for Runs service.
// All implementations must embed UnimplementedRunsServer
// for forward compatibility.
//
// Runs implements all functionality related to a Tharsis Run.
type RunsServer interface {
	// GetRunByID returns a Run by an ID.
	GetRunByID(context.Context, *GetRunByIDRequest) (*Run, error)
	// GetRuns returns a paginated list of Runs.
	GetRuns(context.Context, *GetRunsRequest) (*GetRunsResponse, error)
	// CreateRun creates a new Run.
	CreateRun(context.Context, *CreateRunRequest) (*Run, error)
	// ApplyRun applies a Run.
	ApplyRun(context.Context, *ApplyRunRequest) (*Run, error)
	// CancelRun cancels a Run.
	CancelRun(context.Context, *CancelRunRequest) (*Run, error)
	// GetRunVariables returns variables for a Run.
	GetRunVariables(context.Context, *GetRunVariablesRequest) (*GetRunVariablesResponse, error)
	// GetPlanByID returns a Plan by an ID.
	GetPlanByID(context.Context, *GetPlanByIDRequest) (*Plan, error)
	// GetApplyByID returns an Apply by an ID.
	GetApplyByID(context.Context, *GetApplyByIDRequest) (*Apply, error)
	// UpdatePlan updates a Plan.
	UpdatePlan(context.Context, *UpdatePlanRequest) (*Plan, error)
	// UpdateApply updates an Apply.
	UpdateApply(context.Context, *UpdateApplyRequest) (*Apply, error)
	// GetLatestJobForPlan returns the latest job for a Plan.
	GetLatestJobForPlan(context.Context, *GetLatestJobForPlanRequest) (*Job, error)
	// GetLatestJobForApply returns the latest job for an Apply.
	GetLatestJobForApply(context.Context, *GetLatestJobForApplyRequest) (*Job, error)
	// SubscribeToRunEvents subscribes to run events.
	SubscribeToRunEvents(*SubscribeToRunEventsRequest, grpc.ServerStreamingServer[RunEvent]) error
	mustEmbedUnimplementedRunsServer()
}

// UnimplementedRunsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRunsServer struct{}

func (UnimplementedRunsServer) GetRunByID(context.Context, *GetRunByIDRequest) (*Run, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRunByID not implemented")
}
func (UnimplementedRunsServer) GetRuns(context.Context, *GetRunsRequest) (*GetRunsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRuns not implemented")
}
func (UnimplementedRunsServer) CreateRun(context.Context, *CreateRunRequest) (*Run, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateRun not implemented")
}
func (UnimplementedRunsServer) ApplyRun(context.Context, *ApplyRunRequest) (*Run, error) {
	return nil, status.Error(codes.Unimplemented, "method ApplyRun not implemented")
}
func (UnimplementedRunsServer) CancelRun(context.Context, *CancelRunRequest) (*Run, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelRun not implemented")
}
func (UnimplementedRunsServer) GetRunVariables(context.Context, *GetRunVariablesRequest) (*GetRunVariablesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRunVariables not implemented")
}
func (UnimplementedRunsServer) GetPlanByID(context.Context, *GetPlanByIDRequest) (*Plan, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPlanByID not implemented")
}
func (UnimplementedRunsServer) GetApplyByID(context.Context, *GetApplyByIDRequest) (*Apply, error) {
	return nil, status.Error(codes.Unimplemented, "method GetApplyByID not implemented")
}
func (UnimplementedRunsServer) UpdatePlan(context.Context, *UpdatePlanRequest) (*Plan, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePlan not implemented")
}
func (UnimplementedRunsServer) UpdateApply(context.Context, *UpdateApplyRequest) (*Apply, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateApply not implemented")
}
func (UnimplementedRunsServer) GetLatestJobForPlan(context.Context, *GetLatestJobForPlanRequest) (*Job, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLatestJobForPlan not implemented")
}
func (UnimplementedRunsServer) GetLatestJobForApply(context.Context, *GetLatestJobForApplyRequest) (*Job, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLatestJobForApply not implemented")
}
func (UnimplementedRunsServer) SubscribeToRunEvents(*SubscribeToRunEventsRequest, grpc.ServerStreamingServer[RunEvent]) error {
	return status.Error(codes.Unimplemented, "method SubscribeToRunEvents not implemented")
}
func (UnimplementedRunsServer) mustEmbedUnimplementedRunsServer() {}
func (UnimplementedRunsServer) testEmbeddedByValue()              {}

// UnsafeRunsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RunsServer will
// result in compilation errors.
type UnsafeRunsServer interface {
	mustEmbedUnimplementedRunsServer()
}

func RegisterRunsServer(s grpc.ServiceRegistrar, srv RunsServer) {
	// If the following call panics, it indicates UnimplementedRunsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Runs_ServiceDesc, srv)
}

func _Runs_GetRunByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRunByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunsServer).GetRunByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runs_GetRunByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunsServer).GetRunByID(ctx, req.(*GetRunByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runs_GetRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRunsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunsServer).GetRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runs_GetRuns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunsServer).GetRuns(ctx, req.(*GetRunsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runs_CreateRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunsServer).CreateRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runs_CreateRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunsServer).CreateRun(ctx, req.(*CreateRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runs_ApplyRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunsServer).ApplyRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runs_ApplyRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunsServer).ApplyRun(ctx, req.(*ApplyRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runs_CancelRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunsServer).CancelRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runs_CancelRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunsServer).CancelRun(ctx, req.(*CancelRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runs_GetRunVariables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRunVariablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunsServer).GetRunVariables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runs_GetRunVariables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunsServer).GetRunVariables(ctx, req.(*GetRunVariablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runs_GetPlanByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlanByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunsServer).GetPlanByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runs_GetPlanByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunsServer).GetPlanByID(ctx, req.(*GetPlanByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runs_GetApplyByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetApplyByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunsServer).GetApplyByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runs_GetApplyByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunsServer).GetApplyByID(ctx, req.(*GetApplyByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runs_UpdatePlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePlanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunsServer).UpdatePlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runs_UpdatePlan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunsServer).UpdatePlan(ctx, req.(*UpdatePlanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runs_UpdateApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunsServer).UpdateApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runs_UpdateApply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunsServer).UpdateApply(ctx, req.(*UpdateApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runs_GetLatestJobForPlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestJobForPlanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunsServer).GetLatestJobForPlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runs_GetLatestJobForPlan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunsServer).GetLatestJobForPlan(ctx, req.(*GetLatestJobForPlanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runs_GetLatestJobForApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestJobForApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunsServer).GetLatestJobForApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Runs_GetLatestJobForApply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunsServer).GetLatestJobForApply(ctx, req.(*GetLatestJobForApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Runs_SubscribeToRunEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeToRunEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RunsServer).SubscribeToRunEvents(m, &grpc.GenericServerStream[SubscribeToRunEventsRequest, RunEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Runs_SubscribeToRunEventsServer = grpc.ServerStreamingServer[RunEvent]

// Runs_ServiceDesc is the grpc.ServiceDesc for Runs service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Runs_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "martiancloud.tharsis.api.run.Runs",
	HandlerType: (*RunsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRunByID",
			Handler:    _Runs_GetRunByID_Handler,
		},
		{
			MethodName: "GetRuns",
			Handler:    _Runs_GetRuns_Handler,
		},
		{
			MethodName: "CreateRun",
			Handler:    _Runs_CreateRun_Handler,
		},
		{
			MethodName: "ApplyRun",
			Handler:    _Runs_ApplyRun_Handler,
		},
		{
			MethodName: "CancelRun",
			Handler:    _Runs_CancelRun_Handler,
		},
		{
			MethodName: "GetRunVariables",
			Handler:    _Runs_GetRunVariables_Handler,
		},
		{
			MethodName: "GetPlanByID",
			Handler:    _Runs_GetPlanByID_Handler,
		},
		{
			MethodName: "GetApplyByID",
			Handler:    _Runs_GetApplyByID_Handler,
		},
		{
			MethodName: "UpdatePlan",
			Handler:    _Runs_UpdatePlan_Handler,
		},
		{
			MethodName: "UpdateApply",
			Handler:    _Runs_UpdateApply_Handler,
		},
		{
			MethodName: "GetLatestJobForPlan",
			Handler:    _Runs_GetLatestJobForPlan_Handler,
		},
		{
			MethodName: "GetLatestJobForApply",
			Handler:    _Runs_GetLatestJobForApply_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeToRunEvents",
			Handler:       _Runs_SubscribeToRunEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "run.proto",
}
